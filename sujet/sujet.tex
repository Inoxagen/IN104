\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{ae,lmodern}
\usepackage[french]{babel}

\usepackage{amsmath,amsfonts}

\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\myvec}[1]{\ensuremath{\mathbf{#1}}}

\usepackage[colorlinks]{hyperref}

\title{\textbf{Problème à N corps} \\
       \Large Simuler un (petit) univers\\
       \small version 0}
\author{Ismail Bennani \\
        <\href{mailto:ismail.lahkim.bennani@ens.fr}{ismail.lahkim.bennani@ens.fr}>}

\begin{document}

\maketitle

\noindent\textbf{Mesures exceptionnelles}\\
Étant donnée la situation actuelle, vous pourrez me joindre sur \href{https://join.slack.com/t/in104n-bodyproblem/shared_invite/zt-cu07sew6-nw8ikZtOZBy2UmpqReQdWA}{slack} pour me poser vos questions en plus de mon mail.\\
Je serai aussi disponible via Skype ou Zoom pour faire des points réguliers avec vous.


\section{Projet}

\subsection{Description du problème}

Ce problème consiste à résoudre les équations du mouvement de $N$ corps quelconques interagissant dans un champs gravitationnel en dimension ${n\in \{ 2,3 \}}$.\\
Soient $(c_i)_{i\in[0,N]}$ nos corps. Pour chaque corps $c_i$, on note $m_i \in \mathbb{R}$ sa masse, $\myvec{p_i} \in \mathbb{R}^n$ sa position, $\myvec{v_i} \in \mathbb{R}^n$ sa vitesse et $\myvec{a_i} \in \mathbb{R}^n$ son accélération.\\
Pour chaque couple de corps (distincts) $c_i, c_j$, on note $r_{i,j} = \norm{p_j - p_i}$ la distance euclidienne entre ces corps et $\myvec{u_{i,j}} = \frac{1}{r_{i,j}}(\myvec{p_j}-\myvec{p_i})$ le vecteur unitaire colinéaire au vecteur $\myvec{p_ip_j}$.

La force gravitationnelle appliquée par un corps $j \in [0,N]$ sur un corps $i \in [0,N], i \ne j$ s'écrit:

\begin{equation*}
    \myvec{F_{i,j}} = G \frac{m_im_j}{r_{i,j}} \myvec{u_{i,j}}
\end{equation*}

La dynamique du système est alors décrite par les équations suivantes:

\begin{equation*}
\forall i \in [0,N], \left\{\begin{aligned}
    \ \myvec{\dot{p_i}} & = \myvec{v_i} \\
    \ \myvec{\dot{v_i}} & = \myvec{a_i} \\
    \ \myvec{\dot{a_i}} & = \frac{1}{m_i} \sum_{j \in [0,N], j \ne i} \myvec{F_{i,j}} \\
\end{aligned}\right.
\end{equation*}

\subsection{Travail attendu et évaluation}

Vous écrirez un simulateur capable de calculer l'évolution des positions (en 2D \textbf{OU} 3D) des N corps dans le temps, ce simulateur devra utiliser un solveur d'équations différentielles que vous aurez écrit. Vous écrirez aussi un affichage graphique pour visualiser cette évolution. \\
Le projet est volontairement peu cadré pour que vous puissiez approfondir les parties qui vous intéressent le plus. Vous pourrez par exemple:
\begin{itemize}
    \item implémenter des optimisations pour accélérer le calcul du système d'équations différentielles (cf. section \ref{moteurphysique})
    \item implémenter un solveur d'équations différentielles plus précis que la méthode d'Euler (cf. section \ref{solveur})
    \item implémenter des fonctionnalités pour votre interface graphique (cf. section \ref{interface})
\end{itemize}
Je vous demande à tous d'écrire au moins une version naïve du moteur physique, du solveur et de l'interface graphique qui n'utilise \underline{aucune} librairie externe. Vous pourrez ensuite remplacer des parties de votre code par des interfaces vers un code existant, par exemple utiliser \verb!numpy! pour vos opérations sur les vecteurs et vos opérations matricielles.\\
Je vous conseille donc de penser votre architecture logicielle de manière modulaire, pour qu'il soit facile de changer d'échanger les modules. Par exemple, il faudrait que vous puissiez passer d'une représentation interne des vecteurs à une représentation \verb!numpy! en changeant simplement votre instruction \verb!import .. from ..!.

\vspace{1em}

\noindent Le rendu attendu est une archive contenant
\begin{itemize}
    \item l'intégralité du code source
    \item un \href{https://pip.pypa.io/en/stable/user_guide/#requirements-files}{fichier requirement.txt}
    \item un rapport concis expliquant votre travail, en particulier:
    \begin{itemize}
        \item la répartition des taches dans votre binôme
        \item les librairies externes utilisées
        \item le fonctionnement de votre programme
        \item ce que vous avez approfondi
        \item les difficultés rencontrées et vos solutions, les choix techniques effectués
    \end{itemize}
\end{itemize}

\vspace{1em}

\noindent Je vous suggère d'utiliser Python comme langage de programmation, mais vous pouvez me consulter si vous désirez utiliser autre chose. \\
En section \ref{outils}, je vous parle de quelques librairies utiles pour Python, vous êtes libres d'utiliser les librairies que vous voulez. Par contre, veillez à bien noter dans votre rapport tout ce que vous avez implémenté vous-même et tout ce qui vient d'une librairie externe.

Attention, la valeur d'un code ne se mesure pas au nombre de lignes ! Faites du code commenté (pas besoin de trop en faire) et clair. Veillez par exemple à choisir des noms de variable explicites et informatifs.

\pagebreak

\section{Implémentation}

Dans cette section, je vous décrit une façon d'implémenter le simulateur en trois parties bien délimitées et indépendantes les unes des autres. Vous \textbf{n'êtes pas} tenus de respecter cette implémentation. \\
Je vous conseille vivement de commencer par implémenter les version les plus naïves des différents modules. Cela vous permettra en particulier de réfléchir aux interfaces entre ces modules, de commencer à écrire des tests unitaires, de mettre en place votre dépôt git, et surtout d'avoir une meilleure vision d'ensemble du projet. Contactez moi à ce moment là pour qu'on discute de ce que vous comptez faire par la suite.

\subsection{Moteur Physique}
\label{moteurphysique}

Le rôle du moteur physique est de calculer une approximation de la dynamique du problème. Il s'occupe d'une part de fournir au solveur d'équations différentielles les valeurs à intégrer, et d'autre part de fournir à l'interface graphique les données nécessaires à l'affichage des corps (positions, vitesses, ...). \\
Ce moteur peut gérer les collisions entre corps, considérer que deux corps qui se touchent fusionnent, où ignorer les collisions. Les méthodes que je donne plus bas ignorent les collisions.

Notez que l'efficacité de ce module sera cruciale si vous voulez pouvoir simuler un grand nombre de corps. En effet, la dynamique du système doit être calculée au moins une fois à chaque pas de calcul du solveur d'équations différentielles.

\begin{itemize}
    \item \textbf{Méthode naïve} $\mathcal{O}(N^2)$ \\
    Une approximation simple dans notre cas est celle où les réelles sont représentés par des flottants machines, et où l'accélération d'un corps est obtenue en calculant les $N-1$ forces qu'il subit.\\
    Cependant, on peut être plus efficace en remarquant que
    \begin{equation*}
    \myvec{F_{i,j}} = - \myvec{F_{j,i}}
    \end{equation*}
    Grâce à ça, on peut obtenir le même résultat que précédemment en économisant la moitié des calculs.
    \item \textbf{Simulation de Barnes-Hut} $\mathcal{O}(N log(N))$ \\
    On peut réduire le nombre de calculs à effectuer en sacrifiant en partie la précision de leurs résultats. Cette méthode consiste à construire un arbre (\href{https://en.wikipedia.org/wiki/Octree}{octree}) dont les feuilles sont vos corps, et dont les nœuds intermédiaires représentent des portions de l'espace contenant leurs fils. Dans chaque zone on peut définir un corps virtuel en son centre dont la masse est égale à la somme des masses des corps s'y trouvant. \\
    Ensuite, pour calculer l'interaction gravitationnelle que subit un corps en particulier, on pourra remplacer la contributions d'un groupe de corps éloigné par celle de son corps virtuel. \\
    \url{https://en.wikipedia.org/wiki/Barnes\%E2\%80\%93Hut_simulation}\\
    \url{http://arborjs.org/docs/barnes-hut}
    \item \textbf{Fast multiple methods} $\mathcal{O}(N)$ \\
    \url{https://en.wikipedia.org/wiki/Fast_multipole_method}\\
    \href{https://arxiv.org/pdf/astro-ph/0202512.pdf}{A Hierarchical $\mathcal{O}(N)$ Force Calculation Algorithm}
\end{itemize}

\vspace{1em}

\noindent\textbf{Note} Lors de l'implémentation de ce module, il sera judicieux d'écrire une classe de vecteurs pour représenter les positions, vitesses, accélérations et forces. \\
Vous pourrez aussi surcharger les opérateurs arithmétiques ($+$, $*$, ...) pour manipuler les instances de cette classe.\\
Surcharge opérateurs: \href{https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python/233046-appliquez-des-methodes-speciales#/id/r-232928}{explication}, \href{https://docs.python.org/fr/3/library/operator.html}{liste des opérateurs}

\subsection{Solveur d'équations différentielles}
\label{solveur}

\subsection{Interface graphique}
\label{interface}

\subsection{Outils}
\label{outils}

\end{document}
